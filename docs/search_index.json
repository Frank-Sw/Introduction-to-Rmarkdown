[
["index.html", "Introduction to R Markdown", " Introduction to R Markdown Michael Clark https://m-clark.github.io 2018-02-04 "],
["introduction.html", "Introduction Overview", " Introduction R Markdown is a a flavor of Markdown, a markup language. Markdown can be converted to other formats like html, but is as easy to use as normal text editing. R Markdown allows one to combine normal R code with text to produce a wide variety of document formats. This allows for a continuous transition from initial data import and processing to a finished product, whether journal article, slide presentation, or even a website. Overview Key ideas Literate programming Replicability &amp; reproducible research Dynamic data analysis &amp; report generation Why it’s better than some alternatives What is Markdown? R Markdown files Text Chunks Labels Customization Running code Customization &amp; Configuration YAML Themes Output options html, pdf, doc, notebooks Related languages CSS, HTML, \\(\\LaTeX\\) Alternative Modes Slides Bookdown Shiny Using templates and DRY Other How necessary is an R script for your project? Goals The goal is for you to be able to get started with your own document, and understand the possibilities available to you. You will get a feel for the basic mechanics at play, as well as have ideas on how to customize the result to your own tastes. You should also understand it well enought to use it for your next paper/project/whatever. Prerequisites The only prerquisite is a basic understanding of R. The code in the document won’t be dwealt upon or really explained, as what the code is doesn’t matter in this context. Note the following color coding used in this document: emphasis package function object/class link "],
["concepts.html", "Concepts How to read this chapter Literate Programming Replicability &amp; reproducible research Dynamic data analysis &amp; report generation Comparison to alternatives", " Concepts To use R Markdown effectively, it helps to know why you’d even want to. Let’s talk about some ideas, all of which are related, and which will give you some sense of the goals of effective document generation, and why this approach is superior to others you might try. Some terminology you might have come across: Reproducible research Replicable science Reproducible data analysis Dynamic data analysis Dynamic report generation Literate programming Each of these may mean slightly different things depending on the context and background of the person using them, so one should take care to note precisely what is meant. We’ll examine a couple of these concepts, or at least my particular version of them. How to read this chapter While you are looking at this section, collapse the menu (the button next to the magnifying glass), and snap the document to one side of your screen. Now open this version of it, or save it to your computer and open it in RStudio so you can get the syntax highlighting. Then snap it to the other side of the screen. See the R Markdown used to create this section will get you well on your way to understanding how to use R Markdown. Literate Programming Literate programming, or in the context of research, literate statistical programming, is actually an old idea at this point. I believe that the time is ripe for significantly better documentation of programs, and that we can best achieve this by considering programs to be works of literature. ~ Donald Knuth (1984) You might wonder why, given that such an idea was around even before MS Word, how the latter took over in most, but certainly not all, disciplines in academia, especially given that MS Word was only very recently remotely viable as a means for scientific communication, and many would say still isn’t. The interweaving of code and text is something you already do in normal scripting. Comments in code are not only useful, they are practically required. But in a program script, almost all the emphasis is on the code. With literate programming, we focus on the text, and the code exists to help facilitate our ability to tell a (data-driven) story. In the early days the idea was largely to communicate the idea of the computer program itself. Now, at least in the context we’ll be discussing, our usage of literate programming is generate results that tell the story in a completely human-oriented fashion, possibly without any reference to the code at all. However, the document, in whatever format, does not exist independently of the code, and cannot be generated without it. Consider the following example. This code, which clearly delimited from the text via background and font style, shows how to do an unordered list in markdown using two different methods. Either a - or a * will denote a list item. - item 1 - item 2 * item 3 * item 4 In the previous we have a statement explaining the code, followed by the code itself. We actually don’t need a code comment, because the text explains the code in everyday language. This is a simple example but gets at the essence of the approach. In the document you’re reading right now, there is a delineation for the code itself, but this isn’t visible. However it’s clear what the code part is and what the text part is. The following table shows the results of a regression analysis. Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 37.28 1.878 19.86 0 wt -5.344 0.559 -9.559 0 Fitting linear model: mpg ~ wt Observations Residual Std. Error \\(R^2\\) Adjusted \\(R^2\\) 32 3.046 0.7528 0.7446 So imagine a paper in which the previous text content explains the results while the analysis code resides right where the text is. You didn’t see the code, but you saw some nicely formatted results. I personally didn’t format anything however, those are using default settings. Here is the underlying code. lm(mpg ~ wt, mtcars) %&gt;% summary() %&gt;% pander() Here we see the code, but it isn’t evaluated, because the goal of the text here is not the result but to understand the code. Nothing is copied and pasted, the code and text both reside in the same document. The idea of literate programming, i.e. creating human-understandable programs, can extend beyond reports or slides that you might put together for an analysis, and in fact be used for any setting in which you have to write code at all. Replicability &amp; reproducible research The ideas of replicability and reproducible research are hot topics in various disciplines of late. To begin, neither is precisely defined, and depending on the definition one selects, possibly not very likely or even impossible. They are more ideals to strive for, or goals for certain aspects of the research process. For example, nothing is exactly replicable, if only because time will have passed, and with it some things will have changed about the process, the people involved, the data collection, the analytical tools, etc., since the initial research was conducted. However, we can replicate some things, possibly even exactly, and thus make the results reproducible. Our focus will be on the data analysis side. Let’s start with the following scenario. Various versions of a data set are used leading up to analysis, and after several iterations, finaldata7 is now spread across the computers of the faculty advisor, two graduate students and one undergrad. Two of those finaldata7 data sets, specifically named finaldata7a and finaldata7b, are slightly different from the other two and each other. The undergraduate, who helped with the processing of finaldata2 through finaldata6, has graduated and no longer resides in the same state, nor likely cares any more about the project. Some of the data processing was done with menus in a software package that shall not be named. The script that did the final analysis, called model.Results.C, calls the data using a directory location which no longer exists (and refers only to finaldata7). It does several more data processing steps, but has no comments that would indicate why any of them are being done. Some of the variables are named things like PDQ and V3, but there is no document that would say what those mean. When writing their research document in Microsoft Word, all the values from the analyses were copied and pasted into the tables and text1. The variable names in the document have no exact match to any of the names in any of the data objects. Furthermore, no reference was provided in the text what software or specific packages were used for the analysis. And now, several months later, the journal reviewers have made their comments on the paper, and it’s time to dive back into the analysis. Now, what do you think the odds are that this research group could even reproduce the values reported in the main analysis of the paper? Sadly, up until a couple years ago this was not uncommon, and even certain issues just described are still very common. Such an approach is essentially the antithesis of replicability and reproducible research. Anything that was only done with menus cannot be replicated, and without sufficient documentation it’s not clear what was done even when there is potentially reproducible code. The naming of files, variables and other objects was done poorly, so it will take unnecessary effort to figure out what was done, to what, and when. And even after most things get squared away, there is still a chance the numbers won’t match what was in the paper anyway. While certain tools like Box, Dropbox, Google drive etc. have perhaps helped some, people generally don’t use them for version control, and they are not geared toward academic research specifically. However, using proper naming procedures, the approach of literate programming, and utilizing proper documentation could go a long way even with those tools. Dynamic data analysis &amp; report generation Sometimes the goal is to create an expression of the analysis that is not only to be disseminated to a particular audience, but one which possibly will change over time, as the data itself evolves temporally. In this dynamic setting, the document must be able to handle changes with minimal effort. I can tell you from first hand experience that R markdown can allow one to automatically create custom reports for different audiences on a regular basis without even touching the data for explicit processing, nor the reports after the templates are created, even as the data continues to come in over time. Furthermore, any academic effort that would fall under the heading of science is applicable here. The notion of science as software development is something you should get used to. Print has had its day, but is not viable for scientific advancement as it should take place. Waiting months for feedback or a year to get a paper published after it’s first sent for review is unacceptable. Furthermore, what if more data comes in? A data or modeling bug is found? Other studies shed additional light on the conclusions? In this day an age, are we supposed to just continue to cite a work that may no longer be applicable? Consider arxiv.org. Researchers will put papers there before they are published in journals, ostensibly to provide an openly available, if not necessarily 100% complete, work. Others put working drafts or just use it as a place to float some ideas out there. It is a serious outlet however, and a good chunk of the articles I read in the stats world are there. Look closely at this particular entry. As I write this there have been 5 versions of it, and one has access to any of them. The number of versions in that sentence, 5, is not typed. It is based on R code that scraped the arXiv website and processed the submission history. If something changes, there is no reason not to have a version 6 or however many one wants. In a similar vein, many of my own documents on machine learning, Bayesian analysis, generalized additive models etc. have been regularly updated for several years now. Research is never complete. Data can be augmented, analyses tweaked, visualizations improved. Will the products of your own efforts adapt? Comparison to alternatives MS Word Probably the most common tool I see people use for their scientific and related reporting is Microsoft Word. They fight it for all the normal ‘features’ it provides, then they fight it to get their images to look okay after pasting it from somewhere else, then they fight it early and often to get the tables just the way they like it. Even the slightest change to the data will result in redoing practically everything. In addition, all the pasting and finagling with numbers after almost guarantees errors will arise, and they regularly do. And finally, Word documents look like word documents, even if you convert it to something else. In other words, unimpressive. People using Word directly are not engaged in reproducible research, and if they are coupling it with menu driven statistical analyses, their work should be rejected by any serious journal. If you feel you must have a MS Word document, and you’re wrong about this, because excellent academic research is regularly done without it, know that you can still create a Word document as a final product with R Markdown2. \\(\\LaTeX\\) If you’re reading a printed or pdf document and it appears to be massaging your eyeballs in both its look and feel, it likely was constructed with \\(\\LaTeX\\)3. \\(\\LaTeX\\), along with its derivatives, is a type-setting system specifically designed for scientific or other technical documents by Donald Knuth back in the 1970s. If you aren’t familiar with it, you should know that whole disciplines have essentially required it for communication in their field for many years. What’s more, R has been \\(\\LaTeX\\)-able since the beginning via S expressions and code chunks, allowing one to weave the code and results together in one document. The following shows an example of \\(\\LaTeX\\) syntax. \\documentclass{article} \\title{Use R Markdown in lieu of $\\LaTeX$} \\author{Me, Myself, and I} \\date{November 5th} \\begin{document} \\maketitle Hello world! $$ E = mc^2 $$ \\end{document} \\(\\LaTeX\\) requires a Tex installation. But once you have that you can write a document using the syntax, with the end result typically being a pdf document. When the document is complete, it will look utterly beautiful, precisely because you had fine control over the look and feel of everything. Just like you can tell a Word document by its looks in a bad way, you can often tell if someone used \\(\\LaTeX\\) because of how nice the document looks. Unfortunately, \\(\\LaTeX\\) is also a complete pain in the ass. Your writing is constantly interrupted by the syntax even for the most minor things, you will pull your hair out trying to get images and tables the way you want, and so forth. Your document will look fantastic, but you will not feel better about yourself afterward. The great thing about R Markdown is that you can use \\(\\LaTeX\\) syntax as much or little as you like, still get the same results, and, using the same Tex installation, produce a nice pretty pdf document. The following shows how to do the formula above in R Markdown, and what it produces. $$ E = mc^2 $$ \\[ E = mc^2 \\] It’s exactly the same. Thus, for those who use \\(\\LaTeX\\), their life just got extremely easier, because they can essentially create a \\(\\LaTeX\\) document without any explicit \\(\\LaTeX\\). But if they do want to use it for some things, they can do so just as they did before. There are some who still seem to think \\(\\LaTeX\\) is in fact necessary instead of R Markdown, but they are wrong. You can only do the same or less with it. Why you should switch The main problem for MS Word and \\(\\LaTeX\\), beside those already mentioned, is that they were created for printed documents. In this day and age, not only is printing unnecessary (and environmentally problematic), contorting a document to the confines of print potentially distorts the meaning an author wishes to convey, as well as restricting the means with which they can convey it. In addition, we don’t primarily read print documents anymore. Even avid print readers will admit they see much more text on a screen than they do on a page. Let’s recap the issues with traditional approaches: Possibly not usable for reproducible scholarly research Syntax gets in the way of fluid text Designed for print Wasteful if printed Often very difficult to get figures/tables to look as desired The case for using a markdown approach is now years old and well established. Unfortunately many, but not all, journals are still print-oriented, because their income depends on a closed-source, broken, and un-scientific system of review and publication. Consider the fact that you could blog about your research while conducting it, present preliminary results via R Markdown (because your blog itself is done via R Markdown), get regular feedback from peers along the way, and all this before you’d ever send it off to a journal. Now ask yourself what a print-oriented journal actually offers you? When was the last time you actually opened a print version of a journal? Do you go to a journal site to look for something as opposed to a simple web search or using Google scholar? How many journals do adequate retractions when problems are found4? Is it possible you may actually get more eyeballs and clicks on your work just having it on your own website5? The current paradigm is going to change because it has to, and there is practically no justification for the traditional approach to academic publication. Indeed the change is underway, with some outlets requiring pre-registration, code, and other changes to the usual send-a-pdf-and-we’ll-get-back-to-you approach. You might as well be using tools and an approach that will already accommodate such change. For more on tools for reproducible research in R see the task view. And since this journal still thinks it’s 1990, all the tables had to be at the end of the document, so they aren’t even near the text which refers to them.↩ People sometimes tell me they have to use it because of a collaborator. I would suggest that they explain that it isn’t in the best interest of the research or its products to do so. If the person insists, their role in the research, and certainly the document, should be diminished.↩ You can pronounce it lah-tek or lay-tek, just don’t pronounce it -teks or people who know better will look at you funny. The ‘tex’ is based on the Greek. Also, the stress is on the first syllable.↩ The answer is none, because none of them can seem to do it in a timely fashion, and even top journals such as Nature, Science and others have been known to actually delay and even refuse to do so even in the face of overwhelming evidence of problematic articles. See Retraction Watch for some insight.↩ You certainly will from those who don’t have paid access to journals.↩ "],
["getting-started.html", "Getting Started What is Markdown? Documents Presentations Shiny Apps Templates", " Getting Started What is Markdown? Markdown is basically a syntax that allows you to use plain text for a document, but which will ultimately be converted to any number of other languages, especially HMTL. The basic markdown syntax hasn’t even really been developed for many years, but there are now dozens of flavors, of which R Markdown is one. Most Markdown syntax is preserved and works identically no matter what flavor you use. However the different flavors will have different options or slightly different implementations of certain things. The main point is knowing one flavor means you know some Markdown, and thus would easily work with others. Documents To start using R markdown, simply go to File/New File/R Markdown… As you can see right away, you have your choice of outlets for documents, but can also see other things that will be of interest to you as you get more used to using R Markdown. Documents are what you’ll probably use primarily, especially since they can be used in place of normal R scripts. You have the choice of HTML, PDF and MS Word. The main thing you’ll want to do is make your choice early, because it is not really possible to have the document look like you’d want in all formats simultaneously. As these are the focus of this document, more detail is forthcoming. Presentations You can do slide-style presentations with R Markdown, with three options shown, though two are bizarrely absent. Two shown are HTML based, and you should not even consider Beamer/pdf. Slides are not for printing, and in fact, really don’t work for text in general. They should be very visual if they are to be effective. The two notable formats not shown are revealjs6 and the kind you can create by going to File/New File/R Presentation. I do not recommend the latter. Creating a presentation is easy enough, and the following shows an example. --- title: &quot;Habits&quot; author: John Doe date: March 22, 2005 output: ioslides_presentation --- # In the morning ## Getting up - Turn off alarm - Get out of bed ## Breakfast - Eat eggs - Drink coffee # In the evening ## Dinner - Eat spaghetti - Drink wine ---- ![picture of spaghetti](images/spaghetti.jpg) ## Going to sleep - Get in bed - Count sheep You should really question whether you need slides. They are a highly restrictive format, do not work well with text, and often don’t work well with interactive images. Furthermore, their development and maintenance has never been a priority of the RStudio crowd. Furthermore, there is nothing substantive they offer that can’t be done with standard HTML. Shiny Apps Shiny is an inherently interactive format geared toward the creation of websites and applications. While there are far more apt programming languages than R for creating a website/app, at least Shiny allows you to stay completely within the R environment, and that means you don’t have to be expert in those other languages. You can run shiny apps on your machine well enough, though usually the point is to make something other people can interact with. This means you’ll need some place to house your work, and shinyapps.io allows for some free hosting and other options. As long as you have a web server people will be able to acces your work. Other formats in this area to be aware of are websites and flexdashboard. Templates Templates are available for any number of things, and one can find plenty among specific packages. Once a package with a particular template is installed, you’ll then have it as an option here. All these typically do is provide a R Markdown file similar to when you open a document, with a couple specific options, and demonstration of them if applicable. It’s not much but at least you won’t have to mess with some of it. When I did slides more often I found revealjs the most viable format. The fact that it’s listed second among the slide formats on the R Markdown website yet not a default when choosing, while the base R Presentation isn’t even mentioned on the website, kind of speaks to how much the RStudio folks are interested in these formats.↩ "],
["standard-documents.html", "Standard Documents R Markdown files Text Chunks", " Standard Documents R Markdown files HTML I personally do everything in html because it’s the most flexible and easiest to get things looking the way you want. Text Chunks Labels Customization Running code "],
["common-issues.html", "Common issues Using HTML Chunk options Image options Caching", " Common issues In creating a document there several things that consistently come up that you’ll want to be aware of, and we’ll visit some of those here. Using HTML Chunk options https://yihui.name/knitr/options/ Image options There are primarily three ways you’ll display images. Some will be the result of R code, possibly even interactive. In other instances, you’ll already have access to an image file and want to display it. Technically you could do this with R code as well, but it’d be more trouble than necessary, as markdown and HTML already provide the means. R graphics Where to begin? As near as I can tell there are no less than five ways to manipulate an image that is produced by your R code, and this is not a good thing. Thankfully, the default settings may be enough, but in my experience it rarely is. HTML vs. Others To begin, there are different systems for PDF or MS Word vs. HTML-based documents. The former are what the chunk options of fig.width and fig.height apply to. For reasons I can’t figure out, these are expressed in inches, though no reference to images outside of family portraits ever is. At least it is easy enough to manipulate to your liking. These will not affect your images in html documents, but this isn’t actually mentioned in the documentation. You can also supply fig.width plus fig.asp which will produce a height that is fig.width*fig.height. There is also fig.dim, which will take the two values you would have specified for fig.width and fig.height. If you supply fig.dim with fig.asp, the latter will be ignored. If inches doesn’t make sense to you, you can use dpi, and which will allow you to know think of dpi*out.width as what to expect in terms of pixels. You also have fig.align with options like ‘left’ and ‘center’, and while the documentation suggests it will work in html_documents, it has no effect on htmlwidgets and similar packages that rely on other languages like javascript. Isn’t this fun? What’s funny is that you think we’re even halfway through this. The out.width and out.height options are geared toward HTML based plotting, and are expressed in pixels, or most usefully, percentages. There is also out.extra that will apply additional arguments (e.g. css/img styling). These out.* can also apply to Latex figures but I can’t figure out why. I also find that out.height actually does nothing in many cases. What’s more, you can use them alongside fig.width and fig.height to ensure you’ll have utterly no idea what will be produced in the finished product. The option fig.retina will only work for HTML documents, and will scale your image such that it will “change the chunk option dpi to dpi * fig.retina, and out.width to fig.width * dpi / fig.retina internally; for example, the physical size of an image is doubled and its display size is halved when fig.retina = 2”. Or it might not have any discernable effect that you can actually see in the document. In the following, apparently all of these arguments might have an effect on the resulting image. ``{r, fig.width=3, fig.height=4, out.width=&#39;30%&#39;, fig.retina=2} library(plotly) data %&gt;% plot_ly(width=500) %&gt;% # in pixels! add_markers(~x, ~y) `` In short, for my typical usage, having all these options is not helpful, and mostly just confusing. See the summary for a simplified approach. In addition there are many options, e.g. image file type, captions etc. that may come in handy. Package options As depicted in the above example, you often can modify the display settings of the plot with options of the visualization package you’re using. This will possibly override the chunk options, so use with caution. Markdown Markdown provides a basic way to insert images into the document as follows. ![alt-text](img/myimage.png) It’s identical to a link just with an exclamation point. Unfortunately that’s it. You can’t specify anything about the image, so it’s rarely going to be useful. img The typical way to insert an image is with HTML. This allows you to specify all the options you need to align and style it. &lt;img src=&quot;img/myimage.png&quot; style=&quot;display:block; margin: 0 auto;&quot;&gt; This should probably be your default approach to inserting images in your document. Image summary If you are going to do PDF or MS Word, fig.width, fig.height, and fig.align will likely take care of most of your needs. For HTML, I use out.width plus fig.asp, and that has solved a lot of my issues. For image files I use because the markdown approach is really too barebones. I suggest you set your figure options at the beginning of the document so that your images will be consistent, and modify if necessary for a specific chunk. I don’t see much need for anything beyond svg and png, the latter if file size is a concern only. You’ll want scalable images, as provided by svgThe svglite package will create smaller svg files, and can be specified with fig.dev just like svg or png., because you don’t know what device people are using or if they want to zoom. Caching "],
["customization-configuration.html", "Customization &amp; Configuration YAML Themes CSS", " Customization &amp; Configuration YAML Themes CSS "],
["pdf-word.html", "PDF &amp; Word", " PDF &amp; Word PDF To create PDF documents, you’ll need a \\(\\TeX\\) installation, and for that I suggest tinytex. Once installed, you’ll not need to use it directly, but will now be to knit documents to PDF. With the Tex installation, you’ll also be able to intermingle standard text, Latex, and R code seamlessly. Here is some text! \\medskip ```r x = rnorm(10) ``` $$\\mathrm{SomeFormula} = Q_{123}^2$$ \\pagebreak MS Word As might be obvious, you’ll need MS Word if you’re going to create such documents. I wouldn’t recommend this for anything, and so I will spend very little effort explaining to you how to do it. The main thing you need to know is how to use a template. MS Word defaults have been terrible since its inception. M "]
]
